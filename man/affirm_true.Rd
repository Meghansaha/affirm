% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/affirm_true.R
\name{affirm_true}
\alias{affirm_true}
\title{Affirm True}
\usage{
affirm_true(
  data,
  label,
  condition,
  id = NA_integer_,
  priority = NA_integer_,
  data_frames = NA_character_,
  columns = NA_character_,
  report_listing = NULL,
  data_action = NULL,
  error = getOption("affirm.error", default = FALSE)
)
}
\arguments{
\item{data}{a data frame}

\item{label}{a string used to describe the affirmation}

\item{condition}{expression to check that evaluates to a logical vector, e.g. \code{cyl \%in\% c(4, 6, 8)}.
Use the dot (\code{.}) to reference the passed data frame. If condition results
in a missing value, it is interpreted as \code{FALSE}.}

\item{id, priority, data_frames, columns}{Optional additional information that will be passed to affirmation report.
\itemize{
\item \code{id} must be an integer, e.g. \code{id = 1L}
\item \code{priority} must be an integer, e.g. \code{priority = 1L}
\item \code{data_frames} string of data frame names used in affirmation, e.g. \code{data_frames = "RAND, DM"}
\item \code{columns} string of column names used in affirmation. default is \code{all.vars(condition)}
}}

\item{report_listing}{an expression selecting/filtering rows from \verb{data=} to return in the
issue listing report. The default is to return the result from \code{create_report_listing()},
which are the rows that do \emph{not} met in \verb{condition=}
and columns included in the \verb{condition=} expression along with any columns
set in \code{option('affirm.id_cols')}. The \code{'affirm.id_cols'} option must be a
character vector of column names, where columns will be selected with
\code{dplyr::select(any_of(getOption('affirm.id_cols')))}.}

\item{data_action}{this expression is executed at the end of the function call when supplied.
\itemize{
\item Default is NULL, and the passed data frame in \verb{data=} is returned unaltered.
\item Perhaps you'll need to remove problematic rows: \code{data_action = dplyr::filter(., !(!!condition))}
}}

\item{error}{Logical indicating whether to throw an error when condition is not met. Default is \code{FALSE}.}
}
\value{
data frame
}
\description{
Use this function to affirm an expression is true.
}
\details{
When passing expressions to arguments \verb{report_listing=} and \verb{data_action=},
there are a few things to keep in mind.
\itemize{
\item The expression passed in \verb{condition=} can be used, but note that it has
been captured as an expression inside the function. This means that to
use it, you'll need to use \verb{!!} (bang-bang) to pass it inside a function.
\item In addition to being able to use the \verb{condition=} expression, you can simplify
your code somewhat by referring to \code{lgl_condition}, which is an evaluated logical
vector of the \verb{condition=} expression.
}
}
\examples{
affirm_init(replace = TRUE)

dplyr::as_tibble(mtcars) |>
 affirm_true(
   label = "No. cylinders must be 4, 6, or 8",
   condition = cyl \%in\% c(4, 6, 8)
 )

affirm_close()
}
\seealso{
Other Data Affirmations: 
\code{\link{affirm_false}()},
\code{\link{affirm_na}()},
\code{\link{affirm_no_dupes}()},
\code{\link{affirm_range}()},
\code{\link{affirm_values}()}
}
\concept{Data Affirmations}
